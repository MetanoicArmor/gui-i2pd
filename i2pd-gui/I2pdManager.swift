import SwiftUI
import Foundation

// –ú–æ–¥–µ–ª–∏ –¥–∞–Ω–Ω—ã—Ö
enum LogLevel: String, CaseIterable {
    case info = "INFO"
    case warn = "WARN"
    case error = "ERROR"
    case debug = "DEBUG"
}

struct LogEntry: Identifiable {
    let id = UUID()
    let timestamp: Date
    let level: LogLevel
    let message: String
    
    init(level: LogLevel, message: String) {
        self.timestamp = Date()
        self.level = level
        self.message = message
    }
}

// –û—Å–Ω–æ–≤–Ω–æ–π –º–µ–Ω–µ–¥–∂–µ—Ä –¥–ª—è I2P daemon
class I2pdManager: ObservableObject {
    @Published var isRunning = false
    @Published var isLoading = false
    @Published var uptime = "00:00:00"
    @Published var peerCount = 0
    @Published var logs: [LogEntry] = []
    
    private var i2pdProcess: Process?
    private var logTimer: Timer?
    
    private let executablePath: String
    
    init() {
        // –ü–æ–ª—É—á–∞–µ–º –ø—É—Ç—å –∫ –±–∏–Ω–∞—Ä–Ω–∏–∫—É i2pd –≤–Ω—É—Ç—Ä–∏ —Å–±–æ—Ä–∫–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
        let bundlePath = Bundle.main.resourceURL?.path ?? ""
        var foundPath = "\(bundlePath)/i2pd"
        
        // –ü—ã—Ç–∞–µ–º—Å—è –Ω–∞–π—Ç–∏ i2pd –≤ —Å–∏—Å—Ç–µ–º–Ω—ã—Ö –ø—É—Ç—è—Ö –∫–∞–∫ fallback
        let systemPaths = [
            "./i2pd-gui/i2pd",     // –ü—É—Ç—å –≤ –ø–∞–ø–∫–µ –ø—Ä–æ–µ–∫—Ç–∞ Xcode
            "./i2pd",              // –¢–µ–∫—É—â–∞—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è
            "/Users/vade/GitHub/gui-i2pd/i2pd-gui/i2pd", // –ê–±—Å–æ–ª—é—Ç–Ω—ã–π –ø—É—Ç—å –∫ –Ω–∞—à–µ–º—É –±–∏–Ω–∞—Ä–Ω–∏–∫—É
            "/Users/vade/GitHub/gui-i2pd/i2pd",          // –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –ø—É—Ç—å
            "/usr/local/bin/i2pd", 
            "/opt/homebrew/bin/i2pd", 
            "/usr/bin/i2pd"
        ]
        
        for path in systemPaths {
            if FileManager.default.fileExists(atPath: path) {
                foundPath = path
                break
            }
        }
        
        executablePath = foundPath
        
        // –î–æ–±–∞–≤–∏–º –ª–æ–≥ –æ –Ω–∞–π–¥–µ–Ω–Ω–æ–º –ø—É—Ç–∏ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
        DispatchQueue.main.async { [weak self] in
            self?.addLog(.debug, "–ë–∏–Ω–∞—Ä–Ω–∏–∫ i2pd –Ω–∞–π–¥–µ–Ω –ø–æ –ø—É—Ç–∏: \(foundPath)")
            self?.addLog(.debug, "–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è —Ñ–∞–π–ª–∞: \(FileManager.default.fileExists(atPath: foundPath) ? "‚úÖ –Ω–∞–π–¥–µ–Ω" : "‚ùå –Ω–µ –Ω–∞–π–¥–µ–Ω")")
        }
    }
    
    func startDaemon() {
        isLoading = true
        addLog(.info, "–ó–∞–ø—É—Å–∫ I2P daemon...")
        
        guard FileManager.default.fileExists(atPath: executablePath) else {
            addLog(.error, "–ë–∏–Ω–∞—Ä–Ω–∏–∫ i2pd –Ω–µ –Ω–∞–π–¥–µ–Ω –ø–æ –ø—É—Ç–∏: \(executablePath)")
            isLoading = false
            return
        }
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∑–∞–ø—É—â–µ–Ω –ª–∏ —É–∂–µ –ø—Ä–æ—Ü–µ—Å—Å
        if isRunning {
            addLog(.warn, "I2P daemon —É–∂–µ –∑–∞–ø—É—â–µ–Ω")
            isLoading = false
            return
        }
        
        DispatchQueue.global(qos: .background).async { [weak self] in
            self?.executeI2pdCommand(["--daemon"])
        }
    }
    
    func stopDaemon() {
        isLoading = true
        addLog(.info, "–û—Å—Ç–∞–Ω–æ–≤–∫–∞ I2P daemon...")
        
        DispatchQueue.global(qos: .background).async { [weak self] in
            self?.stopDaemonProcess()
        }
    }
    
    private func stopDaemonProcess() {
        // –£–ø—Ä–æ—â–µ–Ω–Ω–∞—è –∏ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏
        let stopCommand = """
        echo "üîç –û—Å—Ç–∞–Ω–æ–≤–∫–∞ i2pd daemon..." &&
        
        # –ü—Ä–æ—Å—Ç–∞—è –∏ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–∞—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∞ –≤—Å–µ—Ö –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ i2pd daemon
        DAEMON_PIDS=$(ps aux | awk '/i2pd.*daemon/ && !/I2P-GUI/ {print $2}') &&
        
        if [ -n "$DAEMON_PIDS" ]; then
            echo "üìç –ù–∞–π–¥–µ–Ω—ã –ø—Ä–æ—Ü–µ—Å—Å—ã i2pd daemon: $DAEMON_PIDS" &&
            for PID in $DAEMON_PIDS; do
                echo "üõë –û—Ç–ø—Ä–∞–≤–ª—è–µ–º SIGTERM –ø—Ä–æ—Ü–µ—Å—Å—É $PID..." &&
                kill -TERM $PID 2>/dev/null &&
                sleep 1
            done &&
            sleep 2 &&
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∫–∏–µ –ø—Ä–æ—Ü–µ—Å—Å—ã –≤—Å–µ –µ—â–µ —Ä–∞–±–æ—Ç–∞—é—Ç
            REMAINING_PIDS=$(ps aux | awk '/i2pd.*daemon/ && !/I2P-GUI/ {print $2}') &&
            if [ -n "$REMAINING_PIDS" ]; then
                echo "‚ö†Ô∏è –ò—Å–ø–æ–ª—å–∑—É–µ–º SIGKILL –¥–ª—è –æ—Å—Ç–∞–≤—à–∏—Ö—Å—è –ø—Ä–æ—Ü–µ—Å—Å–æ–≤: $REMAINING_PIDS" &&
                for PID in $REMAINING_PIDS; do
                    kill -KILL $PID 2>/dev/null &&
                    echo "üí• –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∞ $PID"
                done &&
                sleep 1
            fi
        else
            echo "‚ÑπÔ∏è –ü—Ä–æ—Ü–µ—Å—Å—ã i2pd daemon –Ω–µ –Ω–∞–π–¥–µ–Ω—ã"
        fi &&
        
        # –§–∏–Ω–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞
        FINAL_PIDS=$(ps aux | awk '/i2pd.*daemon/ && !/I2P-GUI/ {print $2}') &&
        if [ -z "$FINAL_PIDS" ]; then
            echo "‚úÖ i2pd daemon –ø–æ–ª–Ω–æ—Å—Ç—å—é –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω"
        else
            echo "‚ùå –ü—Ä–æ—Ü–µ—Å—Å—ã –≤—Å–µ –µ—â–µ —Ä–∞–±–æ—Ç–∞—é—Ç: $FINAL_PIDS"
        fi
        """
        
        let killProcess = Process()
        killProcess.executableURL = URL(fileURLWithPath: "/bin/bash")
        killProcess.arguments = ["-c", stopCommand]
        
        let pipe = Pipe()
        killProcess.standardOutput = pipe
        killProcess.standardError = pipe
        
        do {
            try killProcess.run()
            killProcess.waitUntilExit()
            
            let data = pipe.fileHandleForReading.readDataToEndOfFile()
            let output = String(data: data, encoding: .utf8) ?? ""
            
            DispatchQueue.main.async { [weak self] in
                let outputLines = output.components(separatedBy: .newlines)
                    .filter { !$0.isEmpty }
                
                if !outputLines.isEmpty {
                    for line in outputLines {
                        self?.addLog(.info, line)
                    }
                } else {
                    self?.addLog(.info, "Daemon –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")
                }
                
                // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å—Ç–∞—Ç—É—Å –∫–∞–∫ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–π
                self?.isRunning = false
                self?.isLoading = false
                
                // –ü–æ–≤—Ç–æ—Ä–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —á–µ—Ä–µ–∑ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–µ–∫—É–Ω–¥
                DispatchQueue.main.asyncAfter(deadline: .now() + 3) { [weak self] in
                    self?.checkDaemonStatus()
                }
            }
            
        } catch {
            DispatchQueue.main.async { [weak self] in
                self?.addLog(.error, "–û—à–∏–±–∫–∞ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ daemon: \(error.localizedDescription)")
                self?.isLoading = false
            }
        }
    }
    
    func restartDaemon() {
        stopDaemon()
        
        // –ñ–¥–µ–º –Ω–µ–º–Ω–æ–≥–æ –ø–µ—Ä–µ–¥ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–æ–º
        DispatchQueue.main.asyncAfter(deadline: .now() + 2) { [weak self] in
            self?.startDaemon()
        }
    }
    
    func checkStatus() {
        isLoading = true
        addLog(.info, "–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–∞—Ç—É—Å–∞...")
        
        DispatchQueue.global(qos: .background).async { [weak self] in
            self?.checkDaemonStatus()
        }
    }
    
    func clearLogs() {
        DispatchQueue.main.async { [weak self] in
            self?.logs.removeAll()
            self?.addLog(.info, "–õ–æ–≥–∏ –æ—á–∏—â–µ–Ω—ã")
        }
    }
    
    private func executeI2pdCommand(_ arguments: [String]) {
        let process = Process()
        process.executableURL = URL(fileURLWithPath: executablePath)
        process.arguments = arguments
        
        addLog(.info, "–í—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –∫–æ–º–∞–Ω–¥–∞: \(executablePath) \(arguments.joined(separator: " "))")
        
        let pipe = Pipe()
        process.standardOutput = pipe
        process.standardError = pipe
        
        do {
            try process.run()
            
            DispatchQueue.main.async { [weak self] in
                self?.i2pdProcess = process
                self?.updateStatus()
            }
            
            // –ß–∏—Ç–∞–µ–º –≤—ã–≤–æ–¥ –∫–æ–º–∞–Ω–¥—ã
            let data = pipe.fileHandleForReading.readDataToEndOfFile()
            if let output = String(data: data, encoding: .utf8) {
                DispatchQueue.main.async { [weak self] in
                    self?.addLog(.info, "–ö–æ–º–∞–Ω–¥–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞: \(output.trimmingCharacters(in: .whitespacesAndNewlines))")
                }
            }
            
            process.waitUntilExit()
            
            DispatchQueue.main.async { [weak self] in
                self?.isLoading = false
            }
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞—Ç—É—Å –ø–æ—Å–ª–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∫–æ–º–∞–Ω–¥—ã
            DispatchQueue.main.asyncAfter(deadline: .now() + 1) { [weak self] in
                self?.checkDaemonStatus()
            }
            
        } catch {
            DispatchQueue.main.async { [weak self] in
                self?.addLog(.error, "–û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∫–æ–º–∞–Ω–¥—ã: \(error.localizedDescription)")
                self?.isLoading = false
            }
        }
    }
    
    private func checkDaemonStatus() {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∑–∞–ø—É—â–µ–Ω –ª–∏ –ø—Ä–æ—Ü–µ—Å—Å —á–µ—Ä–µ–∑ pgrep –∏–ª–∏ –∞–Ω–∞–ª–æ–≥–∏—á–Ω—É—é –∫–æ–º–∞–Ω–¥—É
        let checkProcess = Process()
        checkProcess.executableURL = URL(fileURLWithPath: "/bin/bash")
        checkProcess.arguments = ["-c", "ps aux | awk '/i2pd.*daemon/ && !/I2P-GUI/ {print $2}' | wc -l"]
        
        let pipe = Pipe()
        checkProcess.standardOutput = pipe
        
        do {
            try checkProcess.run()
            checkProcess.waitUntilExit()
            
            let data = pipe.fileHandleForReading.readDataToEndOfFile()
            let output = String(data: data, encoding: .utf8) ?? ""
            
            DispatchQueue.main.async { [weak self] in
                let wasRunning = self?.isRunning ?? false
                self?.isRunning = !output.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
                
                if self?.isRunning != wasRunning {
                    let status = self?.isRunning == true ? "–∑–∞–ø—É—Å—Ç–∏–ª—Å—è" : "–æ—Å—Ç–∞–Ω–æ–≤–∏–ª—Å—è"
                    self?.addLog(.info, "Daemon \(status)")
                }
                
                self?.isLoading = false
                
                if self?.isRunning == true {
                    self?.startStatusMonitoring()
                } else {
                    self?.stopStatusMonitoring()
                }
            }
            
        } catch {
            DispatchQueue.main.async { [weak self] in
                self?.addLog(.error, "–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ç–∞—Ç—É—Å–∞: \(error.localizedDescription)")
                self?.isLoading = false
            }
        }
    }
    
    private func startStatusMonitoring() {
        // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∫–∞–∂–¥—ã–µ 5 —Å–µ–∫—É–Ω–¥
        logTimer = Timer.scheduledTimer(withTimeInterval: 5.0, repeats: true) { [weak self] _ in
            self?.updateStatus()
        }
        
        // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Å—Ä–∞–∑—É
        updateStatus()
    }
    
    private func stopStatusMonitoring() {
        logTimer?.invalidate()
        logTimer = nil
        
        DispatchQueue.main.async { [weak self] in
            self?.uptime = "00:00:00"
            self?.peerCount = 0
        }
    }
    
    private func updateStatus() {
        // –°–∏–º—É–ª—è—Ü–∏—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
        // –í —Ä–µ–∞–ª—å–Ω–æ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ –∑–¥–µ—Å—å –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –∑–∞–ø—Ä–æ—Å –∫ –≤–µ–±-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—É i2pd
        
        DispatchQueue.main.async { [weak self] in
            guard let self = self, self.isRunning else { return }
            
            // –ü—Ä–æ—Å—Ç–∞—è —Å–∏–º—É–ª—è—Ü–∏—è –≤—Ä–µ–º–µ–Ω–∏ —Ä–∞–±–æ—Ç—ã
            let currentUptimeSeconds = Int(Date().timeIntervalSince1970.truncatingRemainder(dividingBy: 86400))
            let hours = currentUptimeSeconds / 3600
            let minutes = (currentUptimeSeconds % 3600) / 60
            let seconds = currentUptimeSeconds % 60
            
            self.uptime = String(format: "%02d:%02d:%02d", hours, minutes, seconds)
            
            // –°–∏–º—É–ª—è—Ü–∏—è –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –ø–∏—Ä–æ–≤
            self.peerCount = Int.random(in: 50...200)
        }
    }
    
    private func addLog(_ level: LogLevel, _ message: String) {
        DispatchQueue.main.async { [weak self] in
            let logEntry = LogEntry(level: level, message: message)
            self?.logs.append(logEntry)
            
            // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ª–æ–≥–æ–≤
            if self?.logs.count ?? 0 > 100 {
                self?.logs.removeFirst((self?.logs.count ?? 0) - 100)
            }
        }
    }
}
